"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = __importDefault(require("ava"));
const path_1 = __importDefault(require("path"));
const sitemap_1 = require("./sitemap");
const source_1 = require("./source");
const solc_output_builder_1 = require("./solc-output-builder");
const emptyReadme = (dir = '') => ({
    path: path_1.default.join(dir, 'README.md'),
    contents: '',
});
const dummyFilter = {
    matcher: () => true,
    files: () => { throw new Error('Unsupported'); },
};
ava_1.default('single readme', t => {
    const source = buildSoliditySource();
    const sitemap = sitemap_1.Sitemap.generate(source, dummyFilter, [emptyReadme()], 'md', 'readmes');
    t.is(sitemap.pages.length, 1);
});
ava_1.default('single readme no contracts', t => {
    const source = buildSoliditySource(b => b
        .file('Foo.sol'));
    const sitemap = sitemap_1.Sitemap.generate(source, dummyFilter, [emptyReadme()], 'md', 'readmes');
    const { pages: [page] } = sitemap;
    t.is(page.contracts.length, 0);
});
ava_1.default('single readme multiple contracts', t => {
    const source = buildSoliditySource(b => b
        .file('Foo.sol')
        .contract('Foo')
        .contract('Bar'));
    const sitemap = sitemap_1.Sitemap.generate(source, dummyFilter, [emptyReadme()], 'md', 'readmes');
    const { pages: [page] } = sitemap;
    t.is(page.contracts.length, 2);
    t.assert(page.contracts.some(c => c.name === 'Foo'));
    t.assert(page.contracts.some(c => c.name === 'Bar'));
});
ava_1.default('single source with file multiple contracts', t => {
    const source = buildSoliditySource(b => b
        .file('test.sol')
        .contract('Foo')
        .contract('Bar'));
    const sitemap = sitemap_1.Sitemap.generate(source, dummyFilter, [], 'md', 'contracts');
    const { pages } = sitemap;
    t.is(pages.length, 2);
    t.assert(pages.some(p => p.path === './Foo.md'));
    t.assert(pages.some(p => p.path === './Bar.md'));
});
ava_1.default('filter subdirectory', t => {
    const source = buildSoliditySource(b => b
        .file('Foo.sol')
        .contract('Foo')
        .file('sub/Bar.sol')
        .contract('Bar'));
    const sitemap = sitemap_1.Sitemap.generate(source, dummyFilter, [emptyReadme('sub')], 'md', 'readmes');
    const { pages: [page] } = sitemap;
    t.is(page.contracts.length, 1);
    t.is(page.contracts[0].name, 'Bar');
});
ava_1.default('filter nested subdirectories', t => {
    const source = buildSoliditySource(b => b
        .file('sub/Bar.sol')
        .contract('Bar')
        .file('sub/sub2/Foo.sol')
        .contract('Foo'));
    const sitemap = sitemap_1.Sitemap.generate(source, dummyFilter, [emptyReadme('sub')], 'md', 'readmes');
    const { pages: [page] } = sitemap;
    t.is(page.contracts.length, 2);
    t.assert(page.contracts.some(c => c.name === 'Bar'));
    t.assert(page.contracts.some(c => c.name === 'Foo'));
});
ava_1.default('links', t => {
    const source = buildSoliditySource(b => b
        .file('sub1/Bar.sol')
        .contract('Bar')
        .file('sub2/Foo.sol')
        .contract('Foo'));
    const sitemap = sitemap_1.Sitemap.generate(source, dummyFilter, [emptyReadme('sub1'), emptyReadme('sub2')], 'md', 'readmes');
    const links = sitemap.links(sitemap.pages[0]);
    t.is(links.length, 2);
    const bar = links[0];
    t.is(bar.target.name, 'Bar');
    t.is(bar.path, 'sub1.md');
    t.is(bar.relativePath, '');
    const foo = links[1];
    t.is(foo.target.name, 'Foo');
    t.is(foo.path, 'sub2.md');
    t.is(foo.relativePath, 'sub2.md');
});
function buildSoliditySource(builder) {
    const solcOutput = new solc_output_builder_1.SolcOutputBuilder();
    if (builder)
        builder(solcOutput);
    return new source_1.Source('', solcOutput, c => c.name);
}
//# sourceMappingURL=sitemap.test.js.map