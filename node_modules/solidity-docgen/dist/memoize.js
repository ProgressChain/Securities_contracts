"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoized = exports.memoize = void 0;
function memoize(target, propertyKey, descriptor) {
    if (descriptor.value instanceof Function) {
        const func = descriptor.value;
        // Did not find a way to avoid this cast to any.
        // See https://github.com/microsoft/TypeScript/issues/34540.
        descriptor.value = memoized(func);
    }
    else if (descriptor.get instanceof Function) {
        const func = descriptor.get;
        descriptor.get = memoized(func);
    }
    return descriptor;
}
exports.memoize = memoize;
function memoized(fn) {
    const thisCache = new WeakMap();
    const defaultCache = new Map();
    function getCache(that) {
        if (typeof that === 'object') {
            return getOrSet(thisCache, that, () => new Map());
        }
        else {
            return defaultCache;
        }
    }
    return function (...args) {
        const cache = getCache(this);
        const key = JSON.stringify(args);
        return getOrSet(cache, key, () => fn.apply(this, args));
    };
}
exports.memoized = memoized;
function getOrSet(map, key, gen) {
    if (map.has(key)) {
        return map.get(key); // Non-null assertion because we check map.has(key) before.
    }
    else {
        const val = gen();
        map.set(key, val);
        return val;
    }
}
//# sourceMappingURL=memoize.js.map