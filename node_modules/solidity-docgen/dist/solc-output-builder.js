"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolcOutputBuilder = void 0;
// fake solc output builder for tests
class SolcOutputBuilder {
    constructor() {
        this.errors = [];
        this.sources = {};
        this._nextId = 0;
        this._contractIds = {};
    }
    file(fileName) {
        this._currentFile = fileName;
        this.sources[fileName] = {
            ast: {
                nodeType: 'SourceUnit',
                nodes: [],
                id: this._getNextId(),
            },
        };
        return this;
    }
    import(importedFileName, aliases = []) {
        var _a;
        const importedSourceUnit = (_a = this.sources[importedFileName]) === null || _a === void 0 ? void 0 : _a.ast;
        if (importedSourceUnit === undefined)
            throw new Error('Imported file does not exist');
        const fileName = this._currentFile;
        if (fileName === undefined)
            throw new Error('No file defined');
        const astNode = {
            nodeType: 'ImportDirective',
            id: this._getNextId(),
            sourceUnit: importedSourceUnit.id,
            symbolAliases: aliases.map(([name, local]) => ({ foreign: { name }, local })),
        };
        this.sources[fileName].ast.nodes.push(astNode);
        return this;
    }
    contract(contractName, ...baseContracts) {
        const fileName = this._currentFile;
        if (fileName === undefined)
            throw new Error('No file defined');
        const id = this._getContractId(contractName);
        const astNode = {
            nodeType: 'ContractDefinition',
            name: contractName,
            documentation: null,
            id,
            linearizedBaseContracts: [id].concat(
            // this isn't really linearizing, but it'll do
            baseContracts.map(name => this._getContractId(name))),
            nodes: [],
        };
        this._currentContract = { astNode };
        this.sources[fileName].ast.nodes.push(astNode);
        return this;
    }
    _getContractId(contractName) {
        if (contractName in this._contractIds) {
            return this._contractIds[contractName];
        }
        else {
            const id = this._getNextId();
            this._contractIds[contractName] = id;
            return id;
        }
    }
    _getNextId() {
        const id = this._nextId;
        this._nextId += 1;
        return id;
    }
    function(functionName, ...argTypes) {
        const contract = this._currentContract;
        if (contract === undefined)
            throw new Error('No contract defined');
        const kind = functionName === 'fallback' || functionName === 'constructor'
            ? functionName
            : 'function';
        const astNode = {
            nodeType: 'FunctionDefinition',
            kind,
            visibility: 'public',
            name: functionName,
            documentation: null,
            parameters: {
                parameters: argTypes.map(t => ({
                    name: '',
                    typeName: {
                        nodeType: 'ElementaryTypeName',
                        typeDescriptions: {
                            typeString: t,
                        },
                    },
                })),
            },
            returnParameters: {
                parameters: [],
            },
        };
        contract.astNode.nodes.push(astNode);
        return this;
    }
    variable(variableName, typeString) {
        const contract = this._currentContract;
        if (contract === undefined)
            throw new Error('No contract defined');
        const astNode = {
            nodeType: 'VariableDeclaration',
            visibility: 'public',
            name: variableName,
            constant: false,
            typeName: {
                nodeType: 'ElementaryTypeName',
                typeDescriptions: {
                    typeString,
                },
            },
        };
        contract.astNode.nodes.push(astNode);
        return this;
    }
}
exports.SolcOutputBuilder = SolcOutputBuilder;
//# sourceMappingURL=solc-output-builder.js.map