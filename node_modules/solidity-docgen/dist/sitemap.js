"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sitemap = exports.sitemapKinds = void 0;
const path_1 = __importDefault(require("path"));
const minimatch_1 = __importDefault(require("minimatch"));
const lodash_1 = require("lodash");
const page_1 = require("./page");
const memoize_1 = require("./memoize");
exports.sitemapKinds = ['contracts', 'readmes', 'single'];
class Sitemap {
    static generate(source, filter, readmes, ext, kind) {
        switch (kind) {
            case 'contracts':
                return new ContractSitemap(source, filter, ext);
            case 'readmes':
                return new ReadmeSitemap(source, filter, readmes);
            case 'single':
                return new DefaultSitemap(source, filter, ext);
        }
    }
    get contracts() {
        return this.source.contracts.filter(c => this.filter.matcher(c.file.path));
    }
    links(origin) {
        function* generate(sitemap) {
            for (const { path, contracts } of sitemap.pages) {
                const relativePath = relative(origin.path, path);
                for (const c of contracts) {
                    for (const target of c.linkable) {
                        yield { target, path, relativePath };
                    }
                }
            }
        }
        return Array.from(generate(this));
    }
}
__decorate([
    memoize_1.memoize
], Sitemap.prototype, "contracts", null);
exports.Sitemap = Sitemap;
class DefaultSitemap extends Sitemap {
    constructor(source, filter, ext) {
        super();
        this.source = source;
        this.filter = filter;
        this.ext = ext;
    }
    get pages() {
        return [new page_1.DefaultPage(this, this.ext, this.contracts)];
    }
}
class ReadmeSitemap extends Sitemap {
    constructor(source, filter, readmes) {
        super();
        this.source = source;
        this.filter = filter;
        this.readmes = readmes;
    }
    get pages() {
        const contracts = groupBy(this.contracts, c => this.locate(c));
        return this.readmes.map(r => new page_1.ReadmePage(this, r, contracts[path_1.default.dirname(r.path)] || []));
    }
    locate(contract) {
        const matches = this.locations.filter(l => isContainedIn(l, contract.file.path));
        return lodash_1.maxBy(matches, l => l.length);
    }
    get locations() {
        return this.readmes.map(r => path_1.default.dirname(r.path));
    }
}
class ContractSitemap extends Sitemap {
    constructor(source, filter, ext) {
        super();
        this.source = source;
        this.filter = filter;
        this.ext = ext;
    }
    get pages() {
        return this.contracts.map(c => new page_1.ContractPage(this, c, this.ext));
    }
}
function isContainedIn(location, file) {
    return minimatch_1.default(file, path_1.default.join(location, '**/*'));
}
function relative(origin, target) {
    if (path_1.default.normalize(origin) === path_1.default.normalize(target)) {
        return '';
    }
    else {
        return path_1.default.relative(path_1.default.dirname(origin), target);
    }
}
function groupBy(collection, key) {
    const res = {};
    for (const elem of collection) {
        const k = key(elem);
        if (k !== undefined) {
            (res[k] || (res[k] = [])).push(elem);
        }
    }
    return res;
}
//# sourceMappingURL=sitemap.js.map